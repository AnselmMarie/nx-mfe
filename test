import { renderHook, act } from '@testing-library/react-hooks';
import { setupServer } from 'msw/node';
import { rest } from 'msw';
import {
  mockExtendableMessageEvent,
  mockFetchEvent,
  mockClient,
  mockWindowClient,
  mockServiceWorkerRegistration,
  mockCrypto,
} from './test-utils'; // Assuming you create a test-utils.ts file

// Mock the global scope for the service worker environment
global.clients = {
  claim: jest.fn(() => Promise.resolve()),
  matchAll: jest.fn(() => Promise.resolve([])),
  get: jest.fn(() => Promise.resolve(null)),
} as unknown as ServiceWorkerClients;

global.registration = {
  unregister: jest.fn(() => Promise.resolve(true)),
} as unknown as ServiceWorkerRegistration;

global.crypto = {
  randomUUID: mockCrypto.randomUUID,
} as Crypto;

global.fetch = jest.fn(() => Promise.resolve(new Response('passthrough'))) as jest.Mock;
global.MessageChannel = jest.fn(() => ({
  port1: { onmessage: jest.fn() },
  port2: { postMessage: jest.fn() },
})) as jest.Mock;

// Import the service worker script (adjust the path as needed)
const serviceWorkerScript = require('../your-service-worker-file');

describe('Service Worker Tests (Jest, RTL, MSW)', () => {
  let messageHandler: (event: ExtendableMessageEvent) => Promise<void>;
  let fetchHandler: (event: FetchEvent) => void;
  const activeClientIds = new Set<string>();

  beforeEach(() => {
    jest.clearAllMocks();
    activeClientIds.clear();

    // Reset mocks in global scope
    global.clients.claim.mockClear();
    global.clients.matchAll.mockClear();
    global.clients.get.mockClear();
    global.registration.unregister.mockClear();
    (global.fetch as jest.Mock).mockClear();
    (global.MessageChannel as jest.Mock).mockClear();
    mockCrypto.randomUUID.mockReturnValue('mock-uuid'); // Reset UUID

    // Extract event listeners from the service worker script
    const mockSelf = {
      addEventListener: jest.fn((type, listener) => {
        if (type === 'message') {
          messageHandler = listener as (event: ExtendableMessageEvent) => Promise<void>;
        } else if (type === 'fetch') {
          fetchHandler = listener as (event: FetchEvent) => void;
        } else if (type === 'install') {
          listener(); // Simulate install event
        } else if (type === 'activate') {
          const mockEvent = { waitUntil: (promise: Promise<any>) => promise } as ExtendableEvent;
          listener(mockEvent); // Simulate activate event
        }
      }),
      skipWaiting: jest.fn(),
      clients: global.clients,
      registration: global.registration,
    } as unknown as ServiceWorkerGlobalScope;

    // Execute the service worker script in the mocked global scope
    serviceWorkerScript.call(mockSelf);
  });

  it('should skip waiting on install', () => {
    expect(mockSelf.skipWaiting).toHaveBeenCalled();
  });

  it('should claim clients on activate', () => {
    expect(global.clients.claim).toHaveBeenCalled();
  });

  describe('message event listener', () => {
    it('should handle KEEPALIVE_REQUEST', async () => {
      const mockSourceClient = mockClient('client-1');
      (global.clients.get as jest.Mock).mockResolvedValue(mockSourceClient);
      const mockPortPostMessage = jest.fn();
      (global.MessageChannel as jest.Mock).mockReturnValue({
        port1: { onmessage: jest.fn() },
        port2: { postMessage: mockPortPostMessage },
      });

      await messageHandler(mockExtendableMessageEvent('KEEPALIVE_REQUEST', mockSourceClient));
      expect(mockPortPostMessage).toHaveBeenCalledWith({ type: 'KEEPALIVE_RESPONSE' }, []);
    });

    it('should handle INTEGRITY_CHECK_REQUEST', async () => {
      const mockSourceClient = mockClient('client-1');
      (global.clients.get as jest.Mock).mockResolvedValue(mockSourceClient);
      const mockPortPostMessage = jest.fn();
      (global.MessageChannel as jest.Mock).mockReturnValue({
        port1: { onmessage: jest.fn() },
        port2: { postMessage: mockPortPostMessage },
      });

      await messageHandler(mockExtendableMessageEvent('INTEGRITY_CHECK_REQUEST', mockSourceClient));
      expect(mockPortPostMessage).toHaveBeenCalledWith(
        {
          type: 'INTEGRITY_CHECK_RESPONSE',
          payload: { packageVersion: '2.6.4', checksum: 'ca7800994cc8bfb5eb961e037c877074' },
        },
        [],
      );
    });

    it('should handle MOCK_ACTIVATE', async () => {
      const mockSourceClient = mockClient('client-1', 'window');
      (global.clients.get as jest.Mock).mockResolvedValue(mockSourceClient);
      const mockPortPostMessage = jest.fn();
      (global.MessageChannel as jest.Mock).mockReturnValue({
        port1: { onmessage: jest.fn() },
        port2: { postMessage: mockPortPostMessage },
      });

      await messageHandler(mockExtendableMessageEvent('MOCK_ACTIVATE', mockSourceClient));
      expect(activeClientIds.has('client-1')).toBe(true);
      expect(mockPortPostMessage).toHaveBeenCalledWith(
        {
          type: 'MOCKING_ENABLED',
          payload: { client: { id: 'client-1', frameType: 'window' } },
        },
        [],
      );
    });

    it('should handle MOCK_DEACTIVATE', async () => {
      const mockSourceClient = mockClient('client-1');
      (global.clients.get as jest.Mock).mockResolvedValue(mockSourceClient);
      activeClientIds.add('client-1');
      await messageHandler(mockExtendableMessageEvent('MOCK_DEACTIVATE', mockSourceClient));
      expect(activeClientIds.has('client-1')).toBe(false);
    });

    it('should handle CLIENT_CLOSED and unregister when no remaining clients', async () => {
      const mockSourceClient = mockClient('client-1');
      (global.clients.get as jest.Mock).mockResolvedValue(mockSourceClient);
      (global.clients.matchAll as jest.Mock).mockResolvedValue([mockSourceClient]);
      activeClientIds.add('client-1');

      await messageHandler(mockExtendableMessageEvent('CLIENT_CLOSED', mockSourceClient));
      expect(activeClientIds.has('client-1')).toBe(false);
      expect(global.registration.unregister).toHaveBeenCalled();
    });

    it('should handle CLIENT_CLOSED and not unregister when there are remaining clients', async () => {
      const mockSourceClient = mockClient('client-1');
      const mockRemainingClient = mockWindowClient('client-2');
      (global.clients.get as jest.Mock).mockResolvedValue(mockSourceClient);
      (global.clients.matchAll as jest.Mock).mockResolvedValue([mockSourceClient, mockRemainingClient]);
      activeClientIds.add('client-1');

      await messageHandler(mockExtendableMessageEvent('CLIENT_CLOSED', mockSourceClient));
      expect(activeClientIds.has('client-1')).toBe(false);
      expect(global.registration.unregister).not.toHaveBeenCalled();
    });

    it('should return early if clientId or clients is not available', async () => {
      const originalClients = global.clients;
      global.clients = undefined as any;
      await messageHandler(mockExtendableMessageEvent('KEEPALIVE_REQUEST', mockClient('client-1')));
      expect((global.MessageChannel as jest.Mock).mock.calls.length).toBe(0);
      global.clients = originalClients;

      await messageHandler({ source: null } as ExtendableMessageEvent);
      expect((global.MessageChannel as jest.Mock).mock.calls.length).toBe(0);
    });

    it('should return early if client is not found', async () => {
      (global.clients.get as jest.Mock).mockResolvedValue(null);
      await messageHandler(mockExtendableMessageEvent('KEEPALIVE_REQUEST', mockClient('non-existent')));
      expect((global.MessageChannel as jest.Mock).mock.calls.length).toBe(0);
    });
  });

  describe('fetch event listener', () => {
    it('should bypass navigation requests', () => {
      const mockRespondWith = jest.fn();
      fetchHandler(mockFetchEvent('/'));
      expect(mockRespondWith).not.toHaveBeenCalled();
    });

    it('should bypass "only-if-cached" requests from different origin', () => {
      const mockRespondWith = jest.fn();
      fetchHandler(mockFetchEvent('/data', 'no-cors', 'only-if-cached', 'GET'));
      expect(mockRespondWith).not.toHaveBeenCalled();
    });

    it('should bypass all requests when no active clients', () => {
      const mockRespondWith = jest.fn();
      fetchHandler(mockFetchEvent('/api/data'));
      expect(mockRespondWith).not.toHaveBeenCalled();
    });

    it('should call handleRequest for other requests', () => {
      const mockRespondWith = jest.fn();
      (global.clients.matchAll as jest.Mock).mockResolvedValue([mockWindowClient('client-1')]);
      activeClientIds.add('client-1');
      fetchHandler(mockFetchEvent('/api/data', 'same-origin', 'default', 'GET', mockRespondWith));
      expect(mockRespondWith).toHaveBeenCalled();
    });
  });

  describe('handleRequest function', () => {
    let handleRequest: (event: FetchEvent, requestId: string) => Promise<Response>;
    const mockResponseClone = new Response('mocked response', {
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'Content-Type': 'application/json' }),
    });

    beforeEach(() => {
      // Extract the handleRequest function
      const mockSelf = {
        addEventListener: jest.fn(),
        skipWaiting: jest.fn(),
        clients: global.clients,
        registration: global.registration,
      } as unknown as ServiceWorkerGlobalScope;
      serviceWorkerScript.call(mockSelf);
      handleRequest = (mockSelf as any).handleRequest; // Access the internal function

      jest.clearAllMocks();
      (global.fetch as jest.Mock).mockResolvedValue(mockResponseClone);
      (global.clients.get as jest.Mock).mockResolvedValue(mockWindowClient('client-1'));
      (global.MessageChannel as jest.Mock).mockReturnValue({
        port1: { onmessage: jest.fn() },
        port2: { postMessage: jest.fn() },
      });
      activeClientIds.add('client-1');
    });

    it('should call getResponse and respond with its result', async () => {
      const mockEvent = mockFetchEvent('/api/data', 'same-origin', 'default', 'GET', jest.fn());
      const mockGetResponse = jest.fn().mockResolvedValue(mockResponseClone);
      (mockSelf as any).getResponse = mockGetResponse; // Mock getResponse

      await handleRequest(mockEvent, 'test-request-id');
      expect(mockGetResponse).toHaveBeenCalledWith(
        mockEvent,
        expect.objectContaining({ id: 'client-1' }),
        'test-request-id',
      );
      expect(mockEvent.respondWith).toHaveBeenCalledWith(Promise.resolve(mockResponseClone));
    });

    it('should send a RESPONSE message to the client', async () => {
      const mockEvent = mockFetchEvent('/api/data', 'same-origin', 'default', 'GET', jest.fn());
      await handleRequest(mockEvent, 'test-request-id');
      expect((global.MessageChannel as jest.Mock)).toHaveBeenCalled();
      const postMessageCall = (global.clients.get as jest.Mock).mock.results[0].value.postMessage;
      expect(postMessageCall).toHaveBeenCalledWith(
        {
          type: 'RESPONSE',
          payload: {
            requestId: 'test-request-id',
            isMockedResponse: false,
            type: 'basic',
            status: 200,
            statusText: 'OK',
            body: mockResponseClone.body,
            headers: { 'content-type': 'application/json' },
          },
        },
        expect.any(Array),
      );
    });

    it('should not send RESPONSE if client is not active', async () => {
      activeClientIds.delete('client-1');
      const mockEvent = mockFetchEvent('/api/data', 'same-origin', 'default', 'GET', jest.fn());
      await handleRequest(mockEvent, 'test-request-id');
      const postMessageCall = (global.clients.get as jest.Mock).mock.results[0].value?.postMessage;
      expect(postMessageCall).not.toHaveBeenCalled();
    });
  });

  describe('resolveMainClient function', () => {
    let resolveMainClient: (event: FetchEvent) => Promise<Client | undefined>;

    beforeEach(() => {
      // Extract the resolveMainClient function
      const mockSelf = {
        addEventListener: jest.fn(),
        skipWaiting: jest.fn(),
        clients: global.clients,
        registration: global.registration,
      } as unknown as ServiceWorkerGlobalScope;
      serviceWorkerScript.call(mockSelf);
      resolveMainClient = (mockSelf as any).resolveMainClient; // Access the internal function

      jest.clearAllMocks();
      (global.clients.get as jest.Mock).mockResolvedValue(null);
      (global.clients.matchAll as jest.Mock).mockResolvedValue([]);
      activeClientIds.clear();
    });

    it('should return the client if it is active', async () => {
      const mockActiveClient = mockWindowClient('active-client');
      (global.clients.get as jest.Mock).mockResolvedValue(mockActiveClient);
      activeClientIds.add('active-client');
      const event = mockFetchEvent('/data', 'same-origin', 'default', 'GET', jest.fn(), 'active-client');
      const client = await resolveMainClient(event);
      expect(client).toBe(mockActiveClient);
    });

    it('should return the client if it is top-level and not active', async () => {
      const mockTopLevelClient = mockClient('top-level-client', 'top-level');
      (global.clients.get as jest.Mock).mockResolvedValue(mockTopLevelClient);
      const event = mockFetchEvent('/data', 'same-origin', 'default', 'GET', jest.fn(), 'top-level-client');
      const client = await resolveMainClient(event);
      expect(client).toBe(mockTopLevelClient);
    });

    it('should return the visible active client from matchAll', async () => {
      const mockActiveVisibleClient = mockWindowClient('visible-active');
      const mockInactiveClient = mockWindowClient('inactive', 'window', 'hidden');
      (global.clients.matchAll as jest.Mock).mockResolvedValue([mockInactiveClient, mockActiveVisibleClient]);
      activeClientIds.add('visible-active');
      const event = mockFetchEvent('/data', 'same-origin', 'default', 'GET', jest.fn(), 'some-other-client');
      const client = await resolveMainClient(event);
      expect(client).toBe(mockActiveVisibleClient);
    });

    it('should return undefined if no visible active client is found', async () => {
      const mockInactiveClient = mockWindowClient('inactive', 'window', 'hidden');
      (global.clients.matchAll as jest.Mock).mockResolvedValue([mockInactiveClient]);
      const event = mockFetchEvent('/data', 'same-origin', 'default', 'GET', jest.fn(), 'some-client');
      const client = await resolveMainClient(event);
      expect(client).toBeUndefined();
    });
  });

  describe('getResponse function', () => {
    let getResponse: (event: FetchEvent, client: Client | undefined, requestId: string) => Promise<Response>;
    const mockPassthroughResponse = new Response('passthrough');
    const mockMockedResponseData = { body: 'mocked data', status: 200, headers: {} };
    const mockMockedResponse = new Response('mocked data', { status: 200 });
    Reflect.defineProperty(mockMockedResponse, Symbol('isMockedResponse'), { value: true, enumerable: true });

    beforeEach(() => {
      // Extract the getResponse function
      const mockSelf = {
        addEventListener: jest.fn(),
        skipWaiting: jest.fn(),
        clients: global.clients,
        registration: global.registration,
      } as unknown as Service
